# This file has been autogenerated. Do not change by hand. 

#' Create a parameter object for the function getDbCaseCrossoverData
#'
#' @details
#' Create an object defining the parameter values.
#'
#' @param useNestingCohort                    Should the study be nested in a cohort (e.g. people witha
#'                                            specific indication)? If not, the study will be nestedin
#'                                            the general population.
#' @param useObservationEndAsNestingEndDate   When using a nesting cohort, should the observationperiod
#'                                            end date be used instead of the cohort end date?
#' @param getVisits                           Get data on visits? This is needed when performing atime-
#'                                            case-control study and matching on visit date isrequested
#'                                            later on.
#' @param studyStartDate                      A calendar date specifying the minimum date where data
#'                                            isused. Date format is 'yyyymmdd'.
#' @param studyEndDate                        A calendar date specifying the maximum date where data
#'                                            isused. Date format is 'yyyymmdd'.
#' @param getTimeControlData                  Should data for time controls be fetched? (needed
#'                                            forcase-time-control analyses.
#'
#' @export
createGetDbCaseCrossoverDataArgs <- function(useNestingCohort = FALSE,
                                             useObservationEndAsNestingEndDate = TRUE,
                                             getVisits = FALSE,
                                             studyStartDate = "",
                                             studyEndDate = "",
                                             getTimeControlData = FALSE) {
  # First: get default values:
  analysis <- list()
  for (name in names(formals(createGetDbCaseCrossoverDataArgs))) {
    analysis[[name]] <- get(name)
  }
  # Second: overwrite defaults with actual values:
  values <- lapply(as.list(match.call())[-1], function(x) eval(x, envir = sys.frame(-3)))
  for (name in names(values)) {
    if (name %in% names(analysis))
      analysis[[name]] <- values[[name]]
  }
  class(analysis) <- "args"
  return(analysis)
}

#' Create a parameter object for the function selectSubjectsToInclude
#'
#' @details
#' Create an object defining the parameter values.
#'
#' @param firstOutcomeOnly   Use the first outcome per person?
#' @param washoutPeriod      Minimum required numbers of days of observation for inclusion as
#'                           eithercase or control.
#' @param matchingCriteria   If provided, a case-time-control analysis will be performed and
#'                           controlswill be matched based on these criteria.
#' @param minAge             Minimum age at which patient time will be included in the analysis.
#'                           Notethat information prior to the min age is still used to determine
#'                           exposurestatus after the minimum age (e.g. when a prescription was started
#'                           justprior to reaching the minimum age). Also, outcomes occurring before
#'                           theminimum age is reached will be considered as prior outcomes when
#'                           usingfirst outcomes only. Age should be specified in years, but
#'                           non-integervalues are allowed. If not specified, no age restriction will
#'                           be applied.
#' @param maxAge             Maximum age at which patient time will be included in the analysis.
#'                           Ageshould be specified in years, but non-integer values are allowed. If
#'                           notspecified, no age restriction will be applied.
#'
#' @export
createSelectSubjectsToIncludeArgs <- function(firstOutcomeOnly = TRUE,
                                              washoutPeriod = 180,
                                              matchingCriteria = NULL,
                                              minAge = NULL,
                                              maxAge = NULL) {
  # First: get default values:
  analysis <- list()
  for (name in names(formals(createSelectSubjectsToIncludeArgs))) {
    analysis[[name]] <- get(name)
  }
  # Second: overwrite defaults with actual values:
  values <- lapply(as.list(match.call())[-1], function(x) eval(x, envir = sys.frame(-3)))
  for (name in names(values)) {
    if (name %in% names(analysis))
      analysis[[name]] <- values[[name]]
  }
  class(analysis) <- "args"
  return(analysis)
}

#' Create a parameter object for the function getExposureStatus
#'
#' @details
#' Create an object defining the parameter values.
#'
#' @param firstExposureOnly      Should only the first exposure per subject be included?
#' @param riskWindowStart        The start of the risk window (in days) relative to the index date.This
#'                               number should be non-positive.
#' @param riskWindowEnd          The end of the risk window (in days) relative to the index date.
#'                               Thisnumber should be non-positive.
#' @param controlWindowOffsets   Offsets in days of the control windows relative to the case window.
#'
#' @export
createGetExposureStatusArgs <- function(firstExposureOnly = FALSE,
                                        riskWindowStart = -30,
                                        riskWindowEnd = 0,
                                        controlWindowOffsets = c(-60)) {
  # First: get default values:
  analysis <- list()
  for (name in names(formals(createGetExposureStatusArgs))) {
    analysis[[name]] <- get(name)
  }
  # Second: overwrite defaults with actual values:
  values <- lapply(as.list(match.call())[-1], function(x) eval(x, envir = sys.frame(-3)))
  for (name in names(values)) {
    if (name %in% names(analysis))
      analysis[[name]] <- values[[name]]
  }
  class(analysis) <- "args"
  return(analysis)
}
